<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Posts | 尾張</title>
<meta name=keywords content><meta name=description content="Posts - 尾張"><meta name=author content><link rel=canonical href=https://prov1dence.top/posts/><link crossorigin=anonymous href=/assets/css/stylesheet.min.c88963fe2d79462000fd0fb1b3737783c32855d340583e4523343f8735c787f0.css integrity="sha256-yIlj/i15RiAA/Q+xs3N3g8MoVdNAWD5FIzQ/hzXHh/A=" rel="preload stylesheet" as=style><link rel=icon href=https://prov1dence.top/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=https://prov1dence.top/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=https://prov1dence.top/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=https://prov1dence.top/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=https://prov1dence.top/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.143.1"><link rel=alternate type=application/rss+xml href=https://prov1dence.top/posts/index.xml><link rel=alternate hreflang=en href=https://prov1dence.top/posts/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="Posts"><meta property="og:description" content="Prov1dence Portfolio"><meta property="og:type" content="website"><meta property="og:url" content="https://prov1dence.top/posts/"><meta property="og:site_name" content="尾張"><meta name=twitter:card content="summary"><meta name=twitter:title content="Posts"><meta name=twitter:description content="Prov1dence Portfolio"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://prov1dence.top/posts/"}]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://prov1dence.top/ accesskey=h title="Home (Alt + H)">Home</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li></ul></span></div><ul id=menu><li><a href=https://prov1dence.top/archives/ title=Posts><span>Posts</span></a></li><li><a href=https://prov1dence.top/about/ title=About><span>About</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://prov1dence.top/>Home</a></div><h1>Posts</h1></header><article class=post-entry><header class=entry-header><h2>Kick Start 2019 Round C</h2></header><section class=entry-content><p>Kick Start 2019 Round C Wiggle Walk (6pts, 12pts) 在一个R * C的矩阵里面移动，遇到已经走过的格子直接跳过。数据保证移动时不会超出给定的矩阵。
Solution: Simulation 用一个visited数组记录已经走过的格子，遇到走过的格子则直接跳过往后遍历。讲道理这个方法时间复杂度是过不了Hidden Test Set的，但是我也不知道为什么就过了。
时间复杂度：O(n^2) 空间复杂度：O(n^2) // C++ #include &lt;iostream> #include &lt;cmath> #include &lt;cstdio> #include &lt;math.h> #include &lt;limits> #include &lt;algorithm> #include &lt;vector> #include &lt;stack> #include &lt;queue> #include &lt;string> #include &lt;map> #include &lt;set> #include &lt;unordered_map> #include &lt;unordered_set> using namespace std; vector&lt;vector&lt;bool>> visited(50001, vector&lt;bool>(50001, false)); void Forward(char &amp;p, int &amp;r, int &amp;c) { if (p == 'E') { while (visited[r][c + 1]) ++c; visited[r][++c] = true; } else if (p == 'W') { while (visited[r][c - 1]) --c; visited[r][--c] = true; } else if (p == 'N') { while (visited[r - 1][c]) --r; visited[--r][c] = true; } else if (p == 'S') { while (visited[r + 1][c]) ++r; visited[++r][c] = true; } } void solve(const int &amp;t) { int n, R, C, r, c; string str; scanf("%d %d %d %d %d", &amp;n, &amp;R, &amp;C, &amp;r, &amp;c); cin >> str; visited = vector&lt;vector&lt;bool>>(50001, vector&lt;bool>(50001, false)); visited[r][c] = true; for (int i = 0; i &lt; n; ++i) Forward(str[i], r, c); printf("Case #%d: %d %d\n", t, r, c); } int main() { int T; scanf("%d", &amp;T); for (int t = 1; t &lt;= T; ++t) solve(t); return 0; } Circuit Board (14pts, 20pts) 在矩阵里找到每一行最大值与最小值不超过K的最大子矩阵。
...</p></section><footer class=entry-footer>&lt;span title='2019-05-26 23:29:45 AEST'>May 26, 2019&lt;/span>&amp;nbsp;·&amp;nbsp;3 min</footer><a class=entry-link aria-label="post link to Kick Start 2019 Round C" href=https://prov1dence.top/posts/kick-start/2019-round-c/></a></article><article class=post-entry><header class=entry-header><h2>Object Detection</h2></header><section class=entry-content><p>Object Detection Object detection deals with detecting instances of objects of a certain class, such as humans, animals, etc, in digital images and videos. Object detection has applications in many areas of computer vision, including image retrieval, face detection, video surveillance, and self-driving, etc. Current detection systems repurpose classifiers to perform detection. To detect an object, these systems take a classifier for that object and evaluate it at various locations and scales in a test image.
...</p></section><footer class=entry-footer>&lt;span title='2019-05-19 19:40:23 AEST'>May 19, 2019&lt;/span>&amp;nbsp;·&amp;nbsp;5 min</footer><a class=entry-link aria-label="post link to Object Detection" href=https://prov1dence.top/posts/deep-learning/object-detection-yolo/></a></article><article class=post-entry><header class=entry-header><h2>Code Jam 2019 Round 1C</h2></header><section class=entry-content><p>Code Jam 2019 Round 1C Robot Programming Strategy (10pts, 18pts) 已知所有人石头剪刀布的出招顺序，每一轮同时和所有人比赛，找到必胜的策略。
Solution: Eliminiating 每一轮遍历当前轮次所有人的出招，如果同时有三种情况（R, P, S）则没有必胜策略，直接输出IMPOSSIBLE；否则返回胜利或打平的策略。
对于已经打败过的对手没有必要再考虑其之后的出招，所以用一个defeated数组保存已经打败过的对手以便直接跳过。因为当前轮次有可能超过对手的出招顺序长度，所以要用i % size获取对手当前的出招。
时间复杂度：O(A ^ 2) 空间复杂度：O(A) #include &lt;iostream> #include &lt;cmath> #include &lt;cstdio> #include &lt;math.h> #include &lt;limits> #include &lt;algorithm> #include &lt;vector> #include &lt;stack> #include &lt;queue> #include &lt;string> #include &lt;map> #include &lt;set> #include &lt;unordered_map> #include &lt;unordered_set> using namespace std; char Decide(const char &amp;R, const char &amp;P, const char &amp;S) { if (R && P && S) return 'X'; if (R && P) return 'P'; if (R && S) return 'R'; if (P && S) return 'S'; if (R) return 'P'; if (P) return 'S'; return 'R'; } bool Defeate(const char &amp;current, const char &amp;opponent) { return (current == 'R' && opponent == 'S') || (current == 'S' && opponent == 'P') || (current == 'P' && opponent == 'R'); } void solve(const int &amp;t) { int A; scanf("%d", &amp;A); int i = 0; vector&lt;string> opponent(A); vector&lt;bool> defeated(A, false); bool R, P, S; string res; for (int a = 0; a &lt; A; ++a) cin >> opponent[a]; while (true) { int current_opponent = 0; R = false, P = false, S = false; for (int a = 0; a &lt; A; ++a) { if (!defeated[a]) { ++current_opponent; if (opponent[a][i % opponent[a].size()] == 'R') R = true; else if (opponent[a][i % opponent[a].size()] == 'P') P = true; else S = true; } } if (current_opponent == 0) break; char result = Decide(R, P, S); if (result == 'X') { res = "IMPOSSIBLE"; break; } res += result; for (int a = 0; a &lt; A; ++a) { if (!defeated[a] && Defeate(result, opponent[a][i % opponent[a].size()])) defeated[a] = true; } ++i; } printf("Case #%d: %s\n", t, res.c_str()); } int main() { int T; scanf("%d", &amp;T); for (int t = 1; t &lt;= T; ++t) solve(t); return 0; } Power Arrangers (11pts, 21pts) // TODO
...</p></section><footer class=entry-footer>&lt;span title='2019-05-07 22:02:15 AEST'>May 7, 2019&lt;/span>&amp;nbsp;·&amp;nbsp;2 min</footer><a class=entry-link aria-label="post link to Code Jam 2019 Round 1C" href=https://prov1dence.top/posts/code-jam/2019-round-1c/></a></article><article class=post-entry><header class=entry-header><h2>Kick Start 2019 Round B</h2></header><section class=entry-content><p>Kick Start 2019 Round B Building Palindromes (5pts, 12pts) 判断给定区间内的子字符串是否是回文串。
Solution: Prefix Sum 判断字符串是否是回文串只需要判断字符串里个数为奇数的字符的数量是否小于等于1，但如果每次都遍历一遍给定的区间肯定会超时，所以我们需要对给定的原始字符串进行预处理，计算出每一个位置的前缀和（从下标为0到下标为i - 1的位置的字符的总数）。这样在查询的时候就只有O(1)的时间复杂度了。
时间复杂度：O(N) 空间复杂度：O(N) // C++ #include &lt;iostream> #include &lt;cmath> #include &lt;cstdio> #include &lt;math.h> #include &lt;limits> #include &lt;algorithm> #include &lt;vector> #include &lt;stack> #include &lt;queue> #include &lt;string> #include &lt;map> #include &lt;set> #include &lt;unordered_map> #include &lt;unordered_set> using namespace std; int main() { int total_test_case_number; cin >> total_test_case_number; for (int case_number = 1; case_number &lt;= total_test_case_number; ++case_number) { int N, Q, m, n, total = 0; cin >> N >> Q; string words; cin >> words; vector&lt;vector&lt;int>> odds(N + 1, vector&lt;int>(26)); for (int i = 1; i &lt;= N; ++i) { for (int j = 0; j &lt; 26; ++j) odds[i][j] = odds[i - 1][j]; ++odds[i][words[i - 1] - 'A']; } for (int q = 0; q &lt; Q; ++q) { cin >> m >> n; int odd = 0; for (int j = 0; j &lt; 26; ++j) odd += ((odds[n][j] - odds[m - 1][j]) % 2 != 0); total += odd &lt;= 1; } printf("Case #%d: %d\n", case_number, total); } return 0; } Energy Stones (17pts, 24pts) 在所有物品消耗完之前吃掉，使得能够获得的energy最多，类似于背包问题。
...</p></section><footer class=entry-footer>&lt;span title='2019-04-21 14:41:22 AEST'>April 21, 2019&lt;/span>&amp;nbsp;·&amp;nbsp;4 min</footer><a class=entry-link aria-label="post link to Kick Start 2019 Round B" href=https://prov1dence.top/posts/kick-start/2019-round-b/></a></article><article class=post-entry><header class=entry-header><h2>Code Jam 2019 Round 1A</h2></header><section class=entry-content><p>Code Jam 2019 Round 1A Pylons (8pts, 23pts) 在m*n的网格里移动，每次移动后的位置不能与之前的位置在同一行/列/对角线上。
Solution: BackTracking 类似于八皇后问题，不过每次的限制条件只和上一个位置有关，可以用回溯解决。
时间复杂度：O(m^2 * n^2) 空间复杂度：O(m * n) // C++ #include &lt;iostream> #include &lt;cmath> #include &lt;cstdio> #include &lt;math.h> #include &lt;limits> #include &lt;algorithm> #include &lt;vector> #include &lt;stack> #include &lt;queue> #include &lt;string> #include &lt;map> #include &lt;set> #include &lt;unordered_map> #include &lt;unordered_set> using namespace std; int m, n; bool BackTracking(int t, int i, int j, vector&lt;vector&lt;bool>> &amp;visited, vector&lt;vector&lt;int>> &amp;res) { visited[i][j] = true; res[t] = {i, j}; if (t + 1 == m * n) return true; for (int x = 0; x &lt; m; ++x) { for (int y = 0; y &lt; n; ++y) { int r = (x + i) % m, c = (y + j) % n; if (!visited[r][c] && r != i && c != j && r + c != i + j && r - c != i - j && BackTracking(t + 1, r, c, visited, res)) return true; } } visited[i][j] = false; return false; } int main() { int total_test_case_number; cin >> total_test_case_number; for (int case_number = 1; case_number &lt;= total_test_case_number; ++case_number) { bool rev = false; cin >> m >> n; if (m > n) { rev = true; swap(n, m); } vector&lt;vector&lt;bool>> visited(m, vector&lt;bool>(n, false)); vector&lt;vector&lt;int>> res(m * n, vector&lt;int>()); printf("Case #%d: ", case_number); if (BackTracking(0, 0, 0, visited, res)) { printf("POSSIBLE\n"); for (int i = 0; i &lt; m * n; ++i) if (!rev) printf("%d %d\n", res[i][0] + 1, res[i][1] + 1); else printf("%d %d\n", res[i][1] + 1, res[i][0] + 1); } else printf("IMPOSSIBLE\n"); } return 0; } Alien Rhyme (10pts, 27pts) 找到后缀相同的一对单词，后缀的长度可以自己定义，其他单词的后缀不能与这一对相同，使得这样的单词对最多。
...</p></section><footer class=entry-footer>&lt;span title='2019-04-13 15:28:11 AEST'>April 13, 2019&lt;/span>&amp;nbsp;·&amp;nbsp;3 min</footer><a class=entry-link aria-label="post link to Code Jam 2019 Round 1A" href=https://prov1dence.top/posts/code-jam/2019-round-1a/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://prov1dence.top/posts/page/9/>« Prev Page</a>
<a class=next href=https://prov1dence.top/posts/page/11/>Next Page »</a></nav></footer></main><footer class=footer><span>Zhengyu &copy; 2025</span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>