<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Posts | 尾張</title>
<meta name=keywords content><meta name=description content="Posts - 尾張"><meta name=author content><link rel=canonical href=https://prov1dence.top/posts/><link crossorigin=anonymous href=/assets/css/stylesheet.min.c88963fe2d79462000fd0fb1b3737783c32855d340583e4523343f8735c787f0.css integrity="sha256-yIlj/i15RiAA/Q+xs3N3g8MoVdNAWD5FIzQ/hzXHh/A=" rel="preload stylesheet" as=style><link rel=icon href=https://prov1dence.top/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=https://prov1dence.top/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=https://prov1dence.top/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=https://prov1dence.top/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=https://prov1dence.top/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.143.1"><link rel=alternate type=application/rss+xml href=https://prov1dence.top/posts/index.xml><link rel=alternate hreflang=en href=https://prov1dence.top/posts/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="Posts"><meta property="og:description" content="Prov1dence Portfolio"><meta property="og:type" content="website"><meta property="og:url" content="https://prov1dence.top/posts/"><meta property="og:site_name" content="尾張"><meta name=twitter:card content="summary"><meta name=twitter:title content="Posts"><meta name=twitter:description content="Prov1dence Portfolio"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://prov1dence.top/posts/"}]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://prov1dence.top/ accesskey=h title="Home (Alt + H)">Home</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li></ul></span></div><ul id=menu><li><a href=https://prov1dence.top/archives/ title=Posts><span>Posts</span></a></li><li><a href=https://prov1dence.top/about/ title=About><span>About</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://prov1dence.top/>Home</a></div><h1>Posts</h1></header><article class=post-entry><header class=entry-header><h2>Code Jam 2019 Qualification Round</h2></header><section class=entry-content><p>Code Jam 2019 Qualification Round Foregone Solution (6pts, 10pts, 1pts) 将一个带有数字4的数拆分为两个不带数字4的数。
Solution: Construction 输入的数一定带有数字4，对于每一位上的数字4，我们可以将其拆分为2+2（或1+3）的两个数。输入数据最大是10的100次方，所以我们可以将其作为字符串处理。
时间复杂度：O(n) 空间复杂度：O(1) // C++ #include &lt;iostream> #include &lt;cmath> #include &lt;math.h> #include &lt;limits> #include &lt;algorithm> #include &lt;vector> #include &lt;stack> #include &lt;queue> #include &lt;string> #include &lt;map> #include &lt;set> #include &lt;unordered_map> #include &lt;unordered_set> using namespace std; int main() { int T; cin >> T; for (int t = 1; t &lt;= T; ++t) { string N; cin >> N; string a, b; for (auto c:N) { a += c == '4' ? '2' : c; b += c == '4' ? '2' : '0'; } while (a[0] == '0') a.erase(a.begin()); while (b[0] == '0') b.erase(b.begin()); cout &lt;&lt; "Case #" &lt;&lt; t &lt;&lt; ": " &lt;&lt; a &lt;&lt; " " &lt;&lt; b &lt;&lt; endl; } } You Can Go Your Own Way (5pts, 9pts, 10pts) 在n*n的矩阵里从(0,0)走到(n-1,n-1)，只能向右或向下走。矩阵里有一条已有的路径，不能与该路径有重合。最常规的做法是DFS/BFS，时间复杂度为O(n^2)。
...</p></section><footer class=entry-footer>2019-04-06 13:40:27 +1000%!(EXTRA string=April 6, 2019)&amp;nbsp;·&amp;nbsp;2 min</footer><a class=entry-link aria-label="post link to Code Jam 2019 Qualification Round" href=https://prov1dence.top/posts/code-jam/2019-qualification-round/></a></article><article class=post-entry><header class=entry-header><h2>Kick Start 2019 Round A</h2></header><section class=entry-content><p>Kick Start 2019 Round A Training (7pts, 13pts) 一共有N个人，从中选P个人，计算这P个人中 skill rating 的最大值与其他人的 skill rating 的差值之和。
$$ \sum_{i}^{j} max(rating) - rating[i] $$
Solution: Sort + Prefix Sum 先对数组排序，然后在长度为N的有序数组中遍历长为P的所有连续子数组，计算子数组中的最大值与其他值的差值之和。
$$ \sum_{i}^{j - 1} rating[j] - rating[i] $$
如果直接遍历长为P的子数组会浪费很多时间，可以将上面的公式简化为如下。
$$ \sum_{i}^{j - 1} rating[j] - rating[i] = rating[j] * (j - 1 - i) - \sum_{i}^{j - 1} rating[i] $$
为了避免重复计算 $$ \sum_{i}^{j - 1} rating[i] $$，可以用一个长为N+1的数组将原始数组的前缀和保存下来，这样每次直接计算 prefix[j] - prefix[i] 就能得到 $$ \sum_{i}^{j - 1} rating[i] $$ 了，时间复杂度是O(N)。
...</p></section><footer class=entry-footer>2019-03-26 14:25:36 AEDT%!(EXTRA string=March 26, 2019)&amp;nbsp;·&amp;nbsp;7 min</footer><a class=entry-link aria-label="post link to Kick Start 2019 Round A" href=https://prov1dence.top/posts/kick-start/2019-round-a/></a></article><article class=post-entry><header class=entry-header><h2>Methods to Prevent Overfitting in Deep Learning</h2></header><section class=entry-content><p>Methods to Prevent Overfitting in Deep Learning Overfitting Overfitting refers to that when a model fits the training data well but cannot predict the test data correctly, we may say that the model lacks the ability of generalization. It is important to figure out how it happens, and how we can prevent overfitting from the very beginning.
Detect Overfitting The simplest way to detect overfitting is to split the dataset into two parts: the training set for training the model, and the test set for testing the accuracy of the model on a dataset that it has never seen before. Of course, we will also partition part of the training set to be the validation set for fine-tuning hyper-parameters. Note that it is necessary to shuffle all the data before splitting.
...</p></section><footer class=entry-footer>2019-03-20 09:55:04 AEDT%!(EXTRA string=March 20, 2019)&amp;nbsp;·&amp;nbsp;5 min</footer><a class=entry-link aria-label="post link to Methods to Prevent Overfitting in Deep Learning" href=https://prov1dence.top/posts/deep-learning/methods-to-prevent-overfitting-in-deep-learning/></a></article><article class=post-entry><header class=entry-header><h2>C++ 智能指针（3）：shared_ptr</h2></header><section class=entry-content><p>C++智能指针（3）：shared_ptr 分析 UniquePointer对象只能绑定单个指针，要实现指针的自动管理和销毁需要引入计数器
private: int *counter; T *pointer; D *deleter; 计数器的主要作用是标识当前指针被几个智能指针对象所引用，在析构当前对象时，使其计数器自减1。如果计数器等于0，则表示已经没有其他的对象在使用当前指针，此时则可以销毁指针，计数器和删除器。
template&lt;typename T, typename D> void SharedPointer&lt;T, D>::release() { if (pointer) { std::cout &lt;&lt; "SharedPointer " &lt;&lt; this &lt;&lt; " counter remains " &lt;&lt; *counter &lt;&lt; std::endl; if (--(*counter) == 0) { std::cout &lt;&lt; "SharedPointer " &lt;&lt; this &lt;&lt; " destructor called." &lt;&lt; std::endl; (*deleter)(pointer); (*deleter)(counter); (*deleter)(deleter); pointer = nullptr; counter = nullptr; deleter = nullptr; } } } reset函数将指针设为other的指针
template&lt;typename T, typename D> void SharedPointer&lt;T, D>::reset(const SharedPointer&lt;T, D> &amp;other) { pointer = other.pointer; counter = other.counter; deleter = other.deleter; if (pointer) ++(*counter); } 析构函数可以直接调用release函数
...</p></section><footer class=entry-footer>2019-01-25 17:47:38 AEDT%!(EXTRA string=January 25, 2019)&amp;nbsp;·&amp;nbsp;7 min</footer><a class=entry-link aria-label="post link to C++ 智能指针（3）：shared_ptr" href=https://prov1dence.top/posts/cpp/smart-pointer/c++-smart-pointer-3/></a></article><article class=post-entry><header class=entry-header><h2>C++ 智能指针（2）：unique_ptr</h2></header><section class=entry-content><p>C++智能指针（2）：unique_ptr 分析 在使用 AutoPointer 的时候会发生所有权转移和内存泄漏的问题，所以我们可以对 AutoPointer 类稍加修改，修复这两个问题。
所有权转移 为了规避可能发生所有权转移的情况，我们可以直接禁止它使用拷贝构造函数和赋值操作符。
UniquePointer(UniquePointer&lt;T> &amp;other) = delete; UniquePointer&lt;T> &amp;operator=(const UniquePointer&lt;T> &amp;other) = delete; 但很多时候我们都需要使用到传递指针的操作，如果只是使用 deleted 函数禁止拷贝构造函数和赋值操作符，那么这个智能指针存在的意义就不大了，我们可以通过 move 语义来实现移动构造函数和移动赋值操作符，从而在使用 UniquePointer 的时候可以在特定情况下进行所有权转移。
UniquePointer(UniquePointer&lt;T> &&amp;other) noexcept; UniquePointer &amp;operator=(UniquePointer &&amp;other) noexcept; 内存泄漏 为了防止发生内存泄漏，我们可以在UniquePointer的私有成员中增加一个删除器，并根据当前指针对象的类型指定删除器，从而防止发生内存泄漏。
class Deleter { template&lt;typename T> void operator()(T *p) { if (p) delete p; } }; template&lt;typename T, typename D> class UniquePointer { ... private: T *pointer; Deleter deleter; }; 实现 根据unique_ptr的源码，能够大致实现UniquePointer类
template&lt;typename T, typename D> class UniquePointer { public: explicit UniquePointer(T *t, const D &amp;d); ~UniquePointer(); T &amp;operator*(); T *operator->(); T *release(); void reset(T *p); UniquePointer(UniquePointer &&amp;other) noexcept; UniquePointer &amp;operator=(UniquePointer &&amp;other) noexcept; UniquePointer(const UniquePointer &amp;other) = delete; UniquePointer &amp;operator=(const UniquePointer &amp;other) = delete; private: T *pointer; D deleter; }; template&lt;typename T, typename D> UniquePointer&lt;T, D>::UniquePointer(T *t, const D &amp;d) { std::cout &lt;&lt; "UniquePointer " &lt;&lt; this &lt;&lt; " constructor called." &lt;&lt; std::endl; this->pointer = t; this->deleter = d; } template&lt;typename T, typename D> UniquePointer&lt;T, D>::~UniquePointer() { std::cout &lt;&lt; "UniquePointer " &lt;&lt; this &lt;&lt; " destructor called." &lt;&lt; std::endl; deleter(this->pointer); } template&lt;typename T, typename D> T &amp;UniquePointer&lt;T, D>::operator*() { return *this->pointer; } template&lt;typename T, typename D> T *UniquePointer&lt;T, D>::operator->() { return this->pointer; } template&lt;typename T, typename D> T *UniquePointer&lt;T, D>::release() { T *new_pointer = this->pointer; this->pointer = nullptr; return new_pointer; } template&lt;typename T, typename D> void UniquePointer&lt;T, D>::reset(T *p) { if (this->pointer != p) { deleter(this->pointer); this->pointer = p; } } template&lt;typename T, typename D> UniquePointer&lt;T, D>::UniquePointer(UniquePointer&lt;T, D> &&amp;other) noexcept { std::cout &lt;&lt; "UniquePointer " &lt;&lt; this &lt;&lt; " move constructor called." &lt;&lt; std::endl; this->pointer = other.release(); deleter(std::move(other.deleter)); } template&lt;typename T, typename D> UniquePointer&lt;T, D> &amp;UniquePointer&lt;T, D>::operator=(UniquePointer&lt;T, D> &&amp;other) noexcept { std::cout &lt;&lt; "UniquePointer " &lt;&lt; this &lt;&lt; " assignment operator called." &lt;&lt; std::endl; if (this->pointer != other.pointer) { reset(other.release()); deleter = std::move(other.deleter); } return *this; } 测试 尝试使用移动构造函数
...</p></section><footer class=entry-footer>2019-01-19 01:02:02 AEDT%!(EXTRA string=January 19, 2019)&amp;nbsp;·&amp;nbsp;6 min</footer><a class=entry-link aria-label="post link to C++ 智能指针（2）：unique_ptr" href=https://prov1dence.top/posts/cpp/smart-pointer/c++-smart-pointer-2/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://prov1dence.top/posts/page/10/>« Prev Page</a>
<a class=next href=https://prov1dence.top/posts/page/12/>Next Page »</a></nav></footer></main><footer class=footer><span>Zhengyu &copy; 2025</span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>