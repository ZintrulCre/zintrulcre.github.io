<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Protocol Buffer Syntax and Encoding | 尾張</title>
<meta name=keywords content><meta name=description content="Protocol Buffer Syntax and Encoding Principles
[toc]
Serialization refers to the process of converting structured data into a format that is easy to store or transmit.
Protocol Buffer, abbreviated as ProtoBuf, is a language- and platform-independent serialization tool developed by Google and open-sourced in 2008. Compared to commonly used serialization tools such as XML, JSON, YAML, and CSV, ProtoBuf has advantages including smaller serialized data size, faster serialization and deserialization, lower maintenance cost through the use of proto files, and backward compatibility. However, because its data exists in the form of binary data streams, it also has the disadvantage of being unreadable to humans."><meta name=author content><link rel=canonical href=https://prov1dence.top/posts/serialization/protocol-buffer-en/><link crossorigin=anonymous href=/assets/css/stylesheet.min.c88963fe2d79462000fd0fb1b3737783c32855d340583e4523343f8735c787f0.css integrity="sha256-yIlj/i15RiAA/Q+xs3N3g8MoVdNAWD5FIzQ/hzXHh/A=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.min.2eadbb982468c11a433a3e291f01326f2ba43f065e256bf792dbd79640a92316.js integrity="sha256-Lq27mCRowRpDOj4pHwEybyukPwZeJWv3ktvXlkCpIxY=" onload=hljs.initHighlightingOnLoad()></script><link rel=icon href=https://prov1dence.top/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=https://prov1dence.top/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=https://prov1dence.top/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=https://prov1dence.top/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=https://prov1dence.top/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.143.1"><link rel=alternate hreflang=en href=https://prov1dence.top/posts/serialization/protocol-buffer-en/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="Protocol Buffer Syntax and Encoding"><meta property="og:description" content="Protocol Buffer Syntax and Encoding Principles
[toc]
Serialization refers to the process of converting structured data into a format that is easy to store or transmit.
Protocol Buffer, abbreviated as ProtoBuf, is a language- and platform-independent serialization tool developed by Google and open-sourced in 2008. Compared to commonly used serialization tools such as XML, JSON, YAML, and CSV, ProtoBuf has advantages including smaller serialized data size, faster serialization and deserialization, lower maintenance cost through the use of proto files, and backward compatibility. However, because its data exists in the form of binary data streams, it also has the disadvantage of being unreadable to humans."><meta property="og:type" content="article"><meta property="og:url" content="https://prov1dence.top/posts/serialization/protocol-buffer-en/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-04-05T21:22:52+08:00"><meta property="article:modified_time" content="2023-04-05T21:22:52+08:00"><meta property="og:site_name" content="尾張"><meta name=twitter:card content="summary"><meta name=twitter:title content="Protocol Buffer Syntax and Encoding"><meta name=twitter:description content="Protocol Buffer Syntax and Encoding Principles
[toc]
Serialization refers to the process of converting structured data into a format that is easy to store or transmit.
Protocol Buffer, abbreviated as ProtoBuf, is a language- and platform-independent serialization tool developed by Google and open-sourced in 2008. Compared to commonly used serialization tools such as XML, JSON, YAML, and CSV, ProtoBuf has advantages including smaller serialized data size, faster serialization and deserialization, lower maintenance cost through the use of proto files, and backward compatibility. However, because its data exists in the form of binary data streams, it also has the disadvantage of being unreadable to humans."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://prov1dence.top/posts/"},{"@type":"ListItem","position":2,"name":"Protocol Buffer Syntax and Encoding","item":"https://prov1dence.top/posts/serialization/protocol-buffer-en/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Protocol Buffer Syntax and Encoding","name":"Protocol Buffer Syntax and Encoding","description":"Protocol Buffer Syntax and Encoding Principles [toc]\nSerialization refers to the process of converting structured data into a format that is easy to store or transmit.\nProtocol Buffer, abbreviated as ProtoBuf, is a language- and platform-independent serialization tool developed by Google and open-sourced in 2008. Compared to commonly used serialization tools such as XML, JSON, YAML, and CSV, ProtoBuf has advantages including smaller serialized data size, faster serialization and deserialization, lower maintenance cost through the use of proto files, and backward compatibility. However, because its data exists in the form of binary data streams, it also has the disadvantage of being unreadable to humans.\n","keywords":[],"articleBody":"Protocol Buffer Syntax and Encoding Principles [toc]\nSerialization refers to the process of converting structured data into a format that is easy to store or transmit.\nProtocol Buffer, abbreviated as ProtoBuf, is a language- and platform-independent serialization tool developed by Google and open-sourced in 2008. Compared to commonly used serialization tools such as XML, JSON, YAML, and CSV, ProtoBuf has advantages including smaller serialized data size, faster serialization and deserialization, lower maintenance cost through the use of proto files, and backward compatibility. However, because its data exists in the form of binary data streams, it also has the disadvantage of being unreadable to humans.\nThis article mainly introduces the usage of ProtoBuf, including the syntax of .proto files and how to use the protoc tool to generate code in different languages, as well as its encoding principles.\n1 Syntax First, download the latest version of ProtoBuf from https://github.com/protocolbuffers/protobuf, and extract the pre-compiled binary file protoc to the environment variable directory. This article uses version 3.15.7:\n$ protoc --version libprotoc 3.15.7 Taking a simple proto file as an example, its syntax is similar to that of C++:\n// msg.proto syntax = \"proto3\"; package Message; message SearchRequest { reserved 6, 9 to 12; reserved \"foo\", \"bar\"; string query = 1; int32 page_number = 2; int32 result_per_page = 3; } message ResultType { message Result { string url = 1; string title = 2; repeated string snippets = 3; } } message SearchResponse { repeated ResultType.Result results = 1; } Use the protoc tool to generate code in the specified language:\nprotoc --proto_path=./ --go_out=./go_out/ --cpp_out=./cpp_out/ msg.proto Here, --proto_path or -I is used to specify the directory where the required proto files and imported proto files are located. If not specified, the current directory is used by default. go_out and cpp_out are used to specify the directories for the generated go and cpp files, respectively. Finally, all proto files that need to be converted are specified. More parameters can be viewed by entering protoc --help.\n1.1 Data Structure The msg.proto file contains two parts: first, the version of ProtoBuf needs to be specified as proto3. If not specified, the compiler will default to using the old version of proto2 syntax. Then, we define the message types we need. Each message type has many fields, and each field corresponds to a unique number, which is used to identify the field in the serialized binary data stream.\nFields and Numbers Fields are divided into two types:\nSingular: the default type of a field, where the field can only have 0 or 1 data; Repeated: similar to an array, where the field can have any number of data, and the order is preserved. When mapping fields to numbers, the following points need to be noted:\nWe can use any number in the range [1, 19000) and (19999, 2^29 - 1] to identify fields. The range [19000, 19999] is reserved for ProtoBuf implementations; When encoding proto files, numbers 1 to 15 occupy 1 byte, and 16 to 2047 occupy 2 bytes. Therefore, commonly used fields are generally mapped to numbers 1 to 15 to save space; Once a number is used, the type of the corresponding field cannot be changed, otherwise it will cause compatibility issues. Composition and Nesting Structures We can directly nest and use another message structure within a message type:\nmessage SearchResponse { message Result { string url = 1; string title = 2; repeated string snippets = 3; } repeated Result results = 1; } If we want to use a child message type nested in another message type, we need to add the parent message type’s name when defining it:\nmessage ResultType { message Result { string url = 1; string title = 2; repeated string snippets = 3; } } message SearchResponse { repeated ResultType.Result results = 1; } Similarly, we can introduce another message type as a field in a message type in a composite way and assign it the repeated property. If the imported message type is in another proto file, we need to import the corresponding file:\n// msg.proto import \"result.proto\"; message SearchResponse { repeated Result results = 1; } // result.proto message Result { string url = 1; string title = 2; repeated string snippets = 3; } import There are two ways to use import: one is to import using a relative path, as in the example above; the other is to use the -I command when generating code with the protoc tool to specify the directory where the proto files are located and import them using an absolute path:\n$ tree . |-- msg.proto `-- result `-- result.proto 1 directory, 2 files $ protoc -I. -I./result/ --go_out=./ msg.proto 1.2 Keywords Packages The purpose of a package is to avoid naming conflicts between different ProtoBuf messages, similar to the namespace in C language:\npackage Message; Services A service is used to define the message types used in RPC. gRPC has extensive use of services, and its definition is similar to defining functions in Go:\nservice SearchService { rpc Search (SearchRequest) returns (SearchResponse); } Options Options can change the way some predefined contexts in the proto file are processed, including but not limited to:\noptimize_for modifies the code generation method and has three types: SPEED for high optimization, CODE_SIZE for reduced code, and LITE_RUNTIME for simplified functionality; packed generates more compact code for repeated fields; deprecated is used for fields that have been deprecated and generally only generates comments. It should be used with the reserved keyword as much as possible. option optimize_for = CODE_SIZE; // ... repeated int32 samples = 4 [packed=true]; int32 old_field = 6 [deprecated=true]; Version Compatibility To make new versions of proto files compatible with older versions, we cannot modify the type of any existing fields to prevent compatibility issues when using old code to parse new data structures.\nWhen we no longer use certain fields, we can delete or comment out both the field and its corresponding number. To prevent accidentally reusing the same number and corresponding to a different type of field, we can use the reserved keyword to mark the deleted fields and numbers and let the compiler check whether these fields and numbers have been reused during compilation:\n// msg.proto message SearchRequest { reserved 3, 6, 9 to 12; reserved \"foo\", \"bar\"; string query = 1; int32 page_number = 2; int32 result_per_page = 3; } $ protoc -I. --go_out=./ msg.proto msg.proto: Field \"result_per_page\" uses reserved number 3. 1.3 Data Types Primitive Types The following list shows all the primitive data types that can be used in proto files:\nType Default Value Description C++ Type Python Type Go Type double 0 double float float64 float 0 float float float32 int32 0 Encoded using varint, so it is recommended to use sint32 for negative numbers int32 int int32 int64 0 Encoded using varint, so it is recommended to use sint64 for negative numbers int64 int/long[3] int64 uint32 0 Encoded using varint uint32 int/long[3] uint32 uint64 0 Encoded using varint uint64 int/long[3] uint64 sint32 0 Encoded using varint, signed int32 int int32 sint64 0 Encoded using varint, signed int64 int/long[3] int64 fixed32 0 Fixed 4 bytes, more efficient than uint32 for values over 228 uint32 int/long[3] uint32 fixed64 0 Fixed 8 bytes, more efficient than uint64 for values over 256 uint64 int/long[3] uint64 sfixed32 0 Fixed 4 bytes int32 int int32 sfixed64 0 Fixed 8 bytes int64 int/long[3] int64 bool false bool bool bool string \"\" Must be encoded in UTF-8 or 7-bit ASCII, and length can’t exceed 232 string str/unicode[4] string bytes \"\" Any byte sequence with length not exceeding 232 string str []byte In addition to these basic types, the default value for enum types is 0 (the first defined enum value), and the default value for repeated fields is empty.\nmap One of the highlights of ProtoBuf is that it has a built-in map data type, where key_type can be any integer type or string type:\nmap map_field = N; Currently, map cannot be modified by repeated, but its effect can be achieved by customizing a map-like structure. The mapping relationship from key_type to value_type needs to be solved manually:\nmessage MapFieldEntry { key_type key = 1; value_type value = 2; } repeated MapFieldEntry map_field = N; Enum Types The enum type definition in the proto file is roughly as follows:\nmessage EnumRequest { enum Corpus { option allow_alias = true; UNIVERSAL = 0; WEB = 1; NET = 1; IMAGES = 2; LOCAL = 3; } Corpus corpus = 1; } There are several points to note when using enum types:\nEnum values must be within the range of 32-bit integers and negative values are not recommended (because enum values are encoded using varint during serialization); There must be an enum variable with a value of 0 in the enum type definition; If you want to define enum types with the same value, you must add option allow_alias = true. Special Types In addition to basic data types such as double, float, and int32, some special data types can also be defined in proto files:\nAny contains a serialized message of any number of bytes; Oneof is similar to union, which means that multiple fields share the same memory block, and only one of them can be assigned a value. 2 Encoding Process The encoding process of ProtoBuf is divided into two parts: first encode the definition of the field to identify its type during the decoding process; then encode the value of the data and compress it. The first part actually uses certain rules to encode the type and number of the field to obtain the field’s tag, and the field name is not used, so even if the field name is modified in actual use, there will be no compatibility issues; the second part uses different algorithms to compress the data of different types to obtain the value, and the two main algorithms used are Varint and ZigZag. After completing these two parts of encoding, concatenate the tag, byte length (only for variable-length types), and value together to obtain the encoded binary data.\n2.1 Tag Encoding The encoding process of the tag is to first map the field type to a wire_type number, and then left shift the field number by 3 bits, and perform bitwise OR with the wire_type, that is, (field_number \u003c\u003c 3) | wire_type. The mapping relationship between the field type and wire_type is as follows:\nwire_type Meaning Storage structure Corresponding field type 0 Use Varint compression [Tag Value] int32, int64, uint32, uint64, sint32, sint64, bool, enum 1 64-bit [Tag Value] fixed64, sfixed64, double 2 Distinguished by length [Tag Length Value] string, bytes, embedded messages, packed repeated fields 3 Start group groups (deprecated) 4 End group groups (deprecated) 5 32-bit [Tag Value] fixed32, sfixed32, float When decoding, it is necessary to provide the correct proto file in order to obtain the definition of the storage structure.\nFor example, if you want to encode a field with field_number = 2 and field type sint64, with wire_type = 0, you can know that (field_number \u003c\u003c 3) | wire_type = 10000, which is encoded as 10;\nSimilarly, during decoding, the last three bits are first extracted using \u0026 111 to obtain the wire_type = 0, and then right-shifted by 3 bits to obtain the field_number = 2.\nIn summary, for the bytes encoded for a field, the last three bits represent the type, and the preceding bits represent the field number.\n2.2 Varint Varint is the main encoding method for integers with WireType == 0. The binary length of data encoded with Varint is not fixed, and the smaller the value of the number, the smaller the length of the encoded bytes. The encoding process consists of three steps:\nFor the binary representation of a number, split it into groups of 7 bits each. Add a most significant bit (msb) to the beginning of each group, with the msb of the largest group equal to 0, and the msb of all other groups equal to 1. Arrange these bytes in little-endian order. For example, let’s take the number 582,963:\nIts binary representation is 10001110010100110011, which can be split into three groups: 0100011, 1001010, and 0110011, which represent 35, 74, and 51, respectively. Add an msb of 0 to the largest group to get 00100011 (still 35), and add an msb of 1 to the other two groups to get 11001010 and 10110011, which represent 202 and 179, respectively. Arrange these three bytes in little-endian order to get 10110011 11001010 00100011, which represent 179, 202, and 35, respectively. This is the final result obtained by encoding with Varint. varint\nTesting encoding of number 582963 using ProtoBuf:\nmessage SingleNumber { int32 Num = 1; } func main() { sn := SingleNumber { Num: 582963, } bytes, err := proto.Marshal(\u0026sn) if err != nil { panic(err) } fmt.Println(bytes) } The result obtained is the same as the steps mentioned above, where the first byte 8 is the key obtained by encoding the field:\n$ go run main.go msg.pb.go [8 179 202 35] Decoding process is also similar:\nfunc main() { b := []byte{8, 179, 202, 35} var sn SingleNumber err := proto.Unmarshal(b, \u0026sn) if err != nil { panic(err) } fmt.Println(sn.GetNum()) } $ go run main.go msg.pb.go 582963 2.3 ZigZag The essence of Varint encoding is to remove leading zeros in the binary representation of a number in order to reduce the number of bytes used by the data. However, when it comes to negative numbers represented in two’s complement, using Varint for encoding would result in 5 bytes for a 32-bit number and 10 bytes for a 64-bit number, which is very inefficient. To optimize this, ProtoBuf uses ZigZag to map signed integers to unsigned integers. The encoding result of a positive number is equivalent to multiplying it by 2, while the encoding result of a negative number is equivalent to multiplying its absolute value by 2 and subtracting 1. The encoded value corresponds to the original data oscillating between positive and negative numbers, as shown in the table below:\nSigned Integer Unsigned Integer Encoding 0 0 -1 1 1 2 -2 3 2147483647 4294967294 -2147483648 4294967295 Its process is also very simple:\nAssume that the binary representation of the encoded number is num, and shift num left by 1 bit to get x. Shift num right by 31 bits (the number of bits in num minus 1) to get y, that is, use the sign bit to cover each bit of num. Perform XOR operation between x and y to get the result z = x ^ y. For example, for the positive number 5:\nx = 5 « 1 = 00000000 00000000 00000000 00001010 y = 5 » 31 = 00000000 00000000 00000000 00000000 z = x ^ y = 00000000 00000000 00000000 00001010, which is 10 For the negative number -5:\nx = -5 « 1 = 11111111 11111111 11111111 11110110 y = -5 » 31 = 11111111 11111111 11111111 11111111 z = x ^ y = 00000000 00000000 00000000 00001001, which is 9 In ProtoBuf, negative numbers are first encoded using ZigZag and then using Varint to achieve further data compression.\n2.4 Other Encoding Processes Variable-Length Types For variable-length types (such as string, bytes, etc.) with WireType == 2, the serialized binary data stream is stored in the [Tag Length Value] format, where Length is the length of the variable-length part. For example:\nmessage SingleNumber { int32 Num = 1; string Str = 2; } func main() { sn := SingleNumber { Num: 582963, Str: \"helloworld\" } bytes, err := proto.Marshal(\u0026sn) if err != nil { panic(err) } fmt.Println(bytes) } $ go run main.go msg.pb.go [8 179 202 35 18 10 104 101 108 108 111 119 111 114 108 100] In the output, the fifth byte 18 is the Tag for string Str = 2, where field_num = 2, wire_type = 2; the sixth byte 10 represents the length of this variable-length type, which means that the value is stored from the seventh byte to the sixteenth byte, with each value being stored as an ASCII character.\nFixed-length types For fixed-length types with WireType == 1 or WireType == 5 (such as fixed32, fixed64, etc.), the length of their serialized binary data is fixed at 4 or 8 bytes, respectively. For example:\nmessage SingleNumber { int32 Num = 1; string Str = 2; fixed32 A = 3; fixed64 B = 4; float C = 5; } func main() { sn := SingleNumber { // Num: 582963, // Str: \"helloworld\", A: 256, B: 257, } bytes, err := proto.Marshal(\u0026sn) if err != nil { fmt.Println(err) return } fmt.Println(bytes) } $ go run main.go msg.pb.go [29 0 1 0 0 33 1 1 0 0 0 0 0 0] In the resulting bytes, the first byte represents the tag of fixed32 A = 3, where field_num = 3, wire_type = 5, and the following 4 bytes are directly stored according to byte order. The fifth byte represents the tag of fixed64 B = 4, where field_num = 4, wire_type = 1, and the following 8 bytes are similarly stored directly according to byte order.\n","wordCount":"2869","inLanguage":"en","datePublished":"2023-04-05T21:22:52+08:00","dateModified":"2023-04-05T21:22:52+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://prov1dence.top/posts/serialization/protocol-buffer-en/"},"publisher":{"@type":"Organization","name":"尾張","logo":{"@type":"ImageObject","url":"https://prov1dence.top/%3Clink%20/%20abs%20url%3E"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://prov1dence.top/ accesskey=h title="Home (Alt + H)">Home</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li></ul></span></div><ul id=menu><li><a href=https://prov1dence.top/archives/ title=Posts><span>Posts</span></a></li><li><a href=https://prov1dence.top/about/ title=About><span>About</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://prov1dence.top/>Home</a>&nbsp;»&nbsp;<a href=https://prov1dence.top/posts/>Posts</a></div><h1 class=post-title>Protocol Buffer Syntax and Encoding</h1><div class=post-meta>2023-04-05 21:22:52 · 14 min</div></header><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#protocol-buffer-syntax-and-encoding-principles aria-label="Protocol Buffer Syntax and Encoding Principles">Protocol Buffer Syntax and Encoding Principles</a><ul><li><a href=#1-syntax aria-label="1 Syntax">1 Syntax</a><ul><li><a href=#11-data-structure aria-label="1.1 Data Structure">1.1 Data Structure</a></li><li><a href=#fields-and-numbers aria-label="Fields and Numbers">Fields and Numbers</a></li><li><a href=#composition-and-nesting-structures aria-label="Composition and Nesting Structures">Composition and Nesting Structures</a></li><li><a href=#import aria-label=import>import</a></li><li><a href=#12-keywords aria-label="1.2 Keywords">1.2 Keywords</a></li><li><a href=#packages aria-label=Packages>Packages</a></li><li><a href=#services aria-label=Services>Services</a></li><li><a href=#options aria-label=Options>Options</a></li><li><a href=#version-compatibility aria-label="Version Compatibility">Version Compatibility</a></li><li><a href=#13-data-types aria-label="1.3 Data Types">1.3 Data Types</a></li><li><a href=#primitive-types aria-label="Primitive Types">Primitive Types</a></li><li><a href=#map aria-label=map>map</a></li><li><a href=#enum-types aria-label="Enum Types">Enum Types</a></li><li><a href=#special-types aria-label="Special Types">Special Types</a></li></ul></li><li><a href=#2-encoding-process aria-label="2 Encoding Process">2 Encoding Process</a><ul><li><a href=#21-tag-encoding aria-label="2.1 Tag Encoding">2.1 Tag Encoding</a></li><li><a href=#22-varint aria-label="2.2 Varint">2.2 Varint</a></li><li><a href=#23-zigzag aria-label="2.3 ZigZag">2.3 ZigZag</a></li><li><a href=#24-other-encoding-processes aria-label="2.4 Other Encoding Processes">2.4 Other Encoding Processes</a></li><li><a href=#variable-length-types aria-label="Variable-Length Types">Variable-Length Types</a></li><li><a href=#fixed-length-types aria-label="Fixed-length types">Fixed-length types</a></li></ul></li></ul></li></ul></div></details></div><div class=post-content><h1 id=protocol-buffer-syntax-and-encoding-principles>Protocol Buffer Syntax and Encoding Principles<a hidden class=anchor aria-hidden=true href=#protocol-buffer-syntax-and-encoding-principles>#</a></h1><p>[toc]</p><p>Serialization refers to the process of converting structured data into a format that is easy to store or transmit.</p><p>Protocol Buffer, abbreviated as ProtoBuf, is a language- and platform-independent serialization tool developed by Google and open-sourced in 2008. Compared to commonly used serialization tools such as XML, JSON, YAML, and CSV, ProtoBuf has advantages including smaller serialized data size, faster serialization and deserialization, lower maintenance cost through the use of proto files, and backward compatibility. However, because its data exists in the form of binary data streams, it also has the disadvantage of being unreadable to humans.</p><p>This article mainly introduces the usage of ProtoBuf, including the syntax of .proto files and how to use the protoc tool to generate code in different languages, as well as its encoding principles.</p><h2 id=1-syntax>1 Syntax<a hidden class=anchor aria-hidden=true href=#1-syntax>#</a></h2><p>First, download the latest version of ProtoBuf from <a href=https://github.com/protocolbuffers/protobuf>https://github.com/protocolbuffers/protobuf</a>, and extract the pre-compiled binary file <code>protoc</code> to the environment variable directory. This article uses version 3.15.7:</p><pre tabindex=0><code>$ protoc --version
libprotoc 3.15.7
</code></pre><p>Taking a simple proto file as an example, its syntax is similar to that of C++:</p><pre tabindex=0><code>// msg.proto
syntax = &#34;proto3&#34;;

package Message;

message SearchRequest {
  reserved 6, 9 to 12;
  reserved &#34;foo&#34;, &#34;bar&#34;;
  string query = 1;
  int32 page_number = 2;
  int32 result_per_page = 3;
}

message ResultType {
  message Result {
    string url = 1;
    string title = 2;
    repeated string snippets = 3;
  }
}

message SearchResponse {
  repeated ResultType.Result results = 1;
}
</code></pre><p>Use the protoc tool to generate code in the specified language:</p><pre tabindex=0><code>protoc --proto_path=./ --go_out=./go_out/ --cpp_out=./cpp_out/ msg.proto
</code></pre><p>Here, <code>--proto_path</code> or <code>-I</code> is used to specify the directory where the required proto files and imported proto files are located. If not specified, the current directory is used by default. <code>go_out</code> and <code>cpp_out</code> are used to specify the directories for the generated go and cpp files, respectively. Finally, all proto files that need to be converted are specified. More parameters can be viewed by entering <code>protoc --help</code>.</p><h3 id=11-data-structure>1.1 Data Structure<a hidden class=anchor aria-hidden=true href=#11-data-structure>#</a></h3><p>The msg.proto file contains two parts: first, the version of ProtoBuf needs to be specified as proto3. If not specified, the compiler will default to using the old version of proto2 syntax. Then, we define the message types we need. Each message type has many <strong>fields</strong>, and each field corresponds to a unique <strong>number</strong>, which is used to identify the field in the serialized binary data stream.</p><h3 id=fields-and-numbers>Fields and Numbers<a hidden class=anchor aria-hidden=true href=#fields-and-numbers>#</a></h3><p><strong>Fields</strong> are divided into two types:</p><ol><li>Singular: the default type of a field, where the field can only have 0 or 1 data;</li><li>Repeated: similar to an array, where the field can have any number of data, and the order is preserved.</li></ol><p>When mapping fields to <strong>numbers</strong>, the following points need to be noted:</p><ol><li>We can use any number in the range [1, 19000) and (19999, 2^29 - 1] to identify fields. The range [19000, 19999] is reserved for ProtoBuf implementations;</li><li>When encoding proto files, numbers 1 to 15 occupy 1 byte, and 16 to 2047 occupy 2 bytes. Therefore, commonly used fields are generally mapped to numbers 1 to 15 to save space;</li><li>Once a number is used, the <strong>type</strong> of the corresponding field cannot be changed, otherwise it will cause compatibility issues.</li></ol><h3 id=composition-and-nesting-structures>Composition and Nesting Structures<a hidden class=anchor aria-hidden=true href=#composition-and-nesting-structures>#</a></h3><p>We can directly <strong>nest</strong> and use another message structure within a message type:</p><pre tabindex=0><code>message SearchResponse {
  message Result {
    string url = 1;
    string title = 2;
    repeated string snippets = 3;
  }
  repeated Result results = 1;
}
</code></pre><p>If we want to use a child message type nested in another message type, we need to add the parent message type&rsquo;s name when defining it:</p><pre tabindex=0><code>message ResultType {
  message Result {
    string url = 1;
    string title = 2;
    repeated string snippets = 3;
  }
}

message SearchResponse {
  repeated ResultType.Result results = 1;
}
</code></pre><p>Similarly, we can introduce another message type as a field in a message type in a composite way and assign it the repeated property. If the imported message type is in another proto file, we need to import the corresponding file:</p><pre tabindex=0><code>// msg.proto
import &#34;result.proto&#34;;

message SearchResponse {
  repeated Result results = 1;
}

// result.proto
message Result {
  string url = 1;
  string title = 2;
  repeated string snippets = 3;
}
</code></pre><h3 id=import>import<a hidden class=anchor aria-hidden=true href=#import>#</a></h3><p>There are two ways to use <strong>import</strong>: one is to import using a <strong>relative path</strong>, as in the example above; the other is to use the <code>-I</code> command when generating code with the protoc tool to specify the directory where the proto files are located and import them using an <strong>absolute path</strong>:</p><pre tabindex=0><code>$ tree
.
|-- msg.proto
`-- result
    `-- result.proto

1 directory, 2 files
$ protoc -I. -I./result/ --go_out=./ msg.proto
</code></pre><h3 id=12-keywords>1.2 Keywords<a hidden class=anchor aria-hidden=true href=#12-keywords>#</a></h3><h3 id=packages>Packages<a hidden class=anchor aria-hidden=true href=#packages>#</a></h3><p>The purpose of a <strong>package</strong> is to avoid naming conflicts between different ProtoBuf messages, similar to the <code>namespace</code> in C language:</p><pre tabindex=0><code>package Message;
</code></pre><h3 id=services>Services<a hidden class=anchor aria-hidden=true href=#services>#</a></h3><p>A <strong>service</strong> is used to define the message types used in RPC. gRPC has extensive use of services, and its definition is similar to defining functions in Go:</p><pre tabindex=0><code>service SearchService {
  rpc Search (SearchRequest) returns (SearchResponse);
}
</code></pre><h3 id=options>Options<a hidden class=anchor aria-hidden=true href=#options>#</a></h3><p><strong>Options</strong> can change the way some predefined contexts in the proto file are processed, including but not limited to:</p><ol><li><code>optimize_for</code> modifies the code generation method and has three types: <code>SPEED</code> for high optimization, <code>CODE_SIZE</code> for reduced code, and <code>LITE_RUNTIME</code> for simplified functionality;</li><li><code>packed</code> generates more compact code for repeated fields;</li><li><code>deprecated</code> is used for fields that have been deprecated and generally only generates comments. It should be used with the <code>reserved</code> keyword as much as possible.</li></ol><pre tabindex=0><code>option optimize_for = CODE_SIZE;
// ...
  repeated int32 samples = 4 [packed=true];
  int32 old_field = 6 [deprecated=true];
</code></pre><h3 id=version-compatibility>Version Compatibility<a hidden class=anchor aria-hidden=true href=#version-compatibility>#</a></h3><p>To make new versions of proto files compatible with older versions, <strong>we cannot modify the type of any existing fields</strong> to prevent compatibility issues when using old code to parse new data structures.</p><p>When we no longer use certain fields, we can delete or comment out both the field and its corresponding number. To prevent accidentally reusing the same number and corresponding to a different type of field, we can use the <code>reserved</code> keyword to mark the deleted fields and numbers and let the compiler check whether these fields and numbers have been reused during compilation:</p><pre tabindex=0><code>// msg.proto
message SearchRequest {
  reserved 3, 6, 9 to 12;
  reserved &#34;foo&#34;, &#34;bar&#34;;
  string query = 1;
  int32 page_number = 2;
  int32 result_per_page = 3;
}
</code></pre><pre tabindex=0><code>$ protoc -I. --go_out=./ msg.proto
msg.proto: Field &#34;result_per_page&#34; uses reserved number 3.
</code></pre><h3 id=13-data-types>1.3 Data Types<a hidden class=anchor aria-hidden=true href=#13-data-types>#</a></h3><h3 id=primitive-types>Primitive Types<a hidden class=anchor aria-hidden=true href=#primitive-types>#</a></h3><p>The following list shows all the primitive data types that can be used in proto files:</p><table><thead><tr><th>Type</th><th>Default Value</th><th>Description</th><th>C++ Type</th><th>Python Type</th><th>Go Type</th></tr></thead><tbody><tr><td>double</td><td>0</td><td></td><td>double</td><td>float</td><td>float64</td></tr><tr><td>float</td><td>0</td><td></td><td>float</td><td>float</td><td>float32</td></tr><tr><td>int32</td><td>0</td><td>Encoded using varint, so it is recommended to use sint32 for negative numbers</td><td>int32</td><td>int</td><td>int32</td></tr><tr><td>int64</td><td>0</td><td>Encoded using varint, so it is recommended to use sint64 for negative numbers</td><td>int64</td><td>int/long[3]</td><td>int64</td></tr><tr><td>uint32</td><td>0</td><td>Encoded using varint</td><td>uint32</td><td>int/long[3]</td><td>uint32</td></tr><tr><td>uint64</td><td>0</td><td>Encoded using varint</td><td>uint64</td><td>int/long[3]</td><td>uint64</td></tr><tr><td>sint32</td><td>0</td><td>Encoded using varint, signed</td><td>int32</td><td>int</td><td>int32</td></tr><tr><td>sint64</td><td>0</td><td>Encoded using varint, signed</td><td>int64</td><td>int/long[3]</td><td>int64</td></tr><tr><td>fixed32</td><td>0</td><td>Fixed 4 bytes, more efficient than uint32 for values over 228</td><td>uint32</td><td>int/long[3]</td><td>uint32</td></tr><tr><td>fixed64</td><td>0</td><td>Fixed 8 bytes, more efficient than uint64 for values over 256</td><td>uint64</td><td>int/long[3]</td><td>uint64</td></tr><tr><td>sfixed32</td><td>0</td><td>Fixed 4 bytes</td><td>int32</td><td>int</td><td>int32</td></tr><tr><td>sfixed64</td><td>0</td><td>Fixed 8 bytes</td><td>int64</td><td>int/long[3]</td><td>int64</td></tr><tr><td>bool</td><td>false</td><td></td><td>bool</td><td>bool</td><td>bool</td></tr><tr><td>string</td><td>""</td><td>Must be encoded in UTF-8 or 7-bit ASCII, and length can&rsquo;t exceed 232</td><td>string</td><td>str/unicode[4]</td><td>string</td></tr><tr><td>bytes</td><td>""</td><td>Any byte sequence with length not exceeding 232</td><td>string</td><td>str</td><td>[]byte</td></tr></tbody></table><p>In addition to these basic types, the default value for enum types is 0 (the first defined enum value), and the default value for repeated fields is empty.</p><h3 id=map>map<a hidden class=anchor aria-hidden=true href=#map>#</a></h3><p>One of the highlights of ProtoBuf is that it has a built-in map data type, where <code>key_type</code> can be any integer type or string type:</p><pre tabindex=0><code>map&lt;key_type, value_type&gt; map_field = N;
</code></pre><p>Currently, map cannot be modified by repeated, but its effect can be achieved by customizing a map-like structure. The mapping relationship from <code>key_type</code> to <code>value_type</code> needs to be solved manually:</p><pre tabindex=0><code>message MapFieldEntry {
    key_type key = 1;
    value_type value = 2;
}
repeated MapFieldEntry map_field = N;
</code></pre><h3 id=enum-types>Enum Types<a hidden class=anchor aria-hidden=true href=#enum-types>#</a></h3><p>The enum type definition in the proto file is roughly as follows:</p><pre tabindex=0><code>message EnumRequest {
  enum Corpus {
    option allow_alias = true;
    UNIVERSAL = 0;
    WEB = 1;
    NET = 1;
    IMAGES = 2;
    LOCAL = 3;
  }
  Corpus corpus = 1;
}
</code></pre><p>There are several points to note when using enum types:</p><ol><li>Enum values must be within the range of 32-bit integers and negative values are not recommended (because enum values are encoded using varint during serialization);</li><li>There must be an enum variable with a value of 0 in the enum type definition;</li><li>If you want to define enum types with the same value, you must add <code>option allow_alias = true</code>.</li></ol><h3 id=special-types>Special Types<a hidden class=anchor aria-hidden=true href=#special-types>#</a></h3><p>In addition to basic data types such as <code>double</code>, <code>float</code>, and <code>int32</code>, some special data types can also be defined in proto files:</p><ol><li><code>Any</code> contains a serialized message of any number of bytes;</li><li><code>Oneof</code> is similar to <code>union</code>, which means that multiple fields share the same memory block, and only one of them can be assigned a value.</li></ol><h2 id=2-encoding-process>2 Encoding Process<a hidden class=anchor aria-hidden=true href=#2-encoding-process>#</a></h2><p>The encoding process of ProtoBuf is divided into two parts: first encode the definition of the field to identify its type during the decoding process; then encode the value of the data and compress it. The first part actually uses certain rules to encode the <strong>type and number of the field</strong> to obtain the field&rsquo;s tag, and the field name is not used, so even if the field name is modified in actual use, there will be no compatibility issues; the second part uses different algorithms to compress the data of different types to obtain the value, and the two main algorithms used are <strong>Varint</strong> and <strong>ZigZag</strong>. After completing these two parts of encoding, concatenate the <strong>tag</strong>, <strong>byte length</strong> (only for variable-length types), and <strong>value</strong> together to obtain the encoded binary data.</p><h3 id=21-tag-encoding>2.1 Tag Encoding<a hidden class=anchor aria-hidden=true href=#21-tag-encoding>#</a></h3><p>The encoding process of the tag is to first map the field type to a wire_type number, and then left shift the field number by 3 bits, and perform bitwise OR with the wire_type, that is, <code>(field_number &lt;&lt; 3) | wire_type</code>. The mapping relationship between the field type and wire_type is as follows:</p><table><thead><tr><th>wire_type</th><th>Meaning</th><th>Storage structure</th><th>Corresponding field type</th></tr></thead><tbody><tr><td>0</td><td>Use Varint compression</td><td>[Tag Value]</td><td>int32, int64, uint32, uint64, sint32, sint64, bool, enum</td></tr><tr><td>1</td><td>64-bit</td><td>[Tag Value]</td><td>fixed64, sfixed64, double</td></tr><tr><td>2</td><td>Distinguished by length</td><td>[Tag Length Value]</td><td>string, bytes, embedded messages, packed repeated fields</td></tr><tr><td>3</td><td>Start group</td><td></td><td>groups (deprecated)</td></tr><tr><td>4</td><td>End group</td><td></td><td>groups (deprecated)</td></tr><tr><td>5</td><td>32-bit</td><td>[Tag Value]</td><td>fixed32, sfixed32, float</td></tr></tbody></table><p>When decoding, it is necessary to provide the correct proto file in order to obtain the definition of the storage structure.</p><p>For example, if you want to encode a field with field_number = 2 and field type sint64, with wire_type = 0, you can know that <code>(field_number &lt;&lt; 3) | wire_type = 10000</code>, which is encoded as 10;</p><p><img loading=lazy src=https://raw.githubusercontent.com/chr1sc2y/warehouse-deprecated/refs/heads/main/resources/serialization/protobuf-encoding.png alt=https://raw.githubusercontent.com/chr1sc2y/warehouse-deprecated/refs/heads/main/resources/serialization/protobuf-encoding.png></p><p>Similarly, during decoding, the last three bits are first extracted using <code>& 111</code> to obtain the wire_type = 0, and then right-shifted by 3 bits to obtain the field_number = 2.</p><p>In summary, for the bytes encoded for a field, the <strong>last three bits represent the type</strong>, and the <strong>preceding bits represent the field number</strong>.</p><h3 id=22-varint>2.2 Varint<a hidden class=anchor aria-hidden=true href=#22-varint>#</a></h3><p>Varint is the main encoding method for integers with <code>WireType == 0</code>. The binary length of data encoded with Varint is not fixed, and the smaller the value of the number, the smaller the length of the encoded bytes. The encoding process consists of three steps:</p><ol><li>For the binary representation of a number, split it into groups of 7 bits each.</li><li>Add a most significant bit (msb) to the beginning of each group, with the msb of the largest group equal to 0, and the msb of all other groups equal to 1.</li><li>Arrange these bytes in little-endian order.</li></ol><p>For example, let&rsquo;s take the number 582,963:</p><ol><li>Its binary representation is 10001110010100110011, which can be split into three groups: 0100011, 1001010, and 0110011, which represent 35, 74, and 51, respectively.</li><li>Add an msb of 0 to the largest group to get 00100011 (still 35), and add an msb of 1 to the other two groups to get 11001010 and 10110011, which represent 202 and 179, respectively.</li><li>Arrange these three bytes in little-endian order to get 10110011 11001010 00100011, which represent 179, 202, and 35, respectively. This is the final result obtained by encoding with Varint.</li></ol><p><img loading=lazy src=https://raw.githubusercontent.com/chr1sc2y/warehouse-deprecated/refs/heads/main/resources/serialization/varint.png alt=https://raw.githubusercontent.com/chr1sc2y/warehouse-deprecated/refs/heads/main/resources/serialization/varint.png></p><p>varint</p><p>Testing encoding of number 582963 using ProtoBuf:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-protobuf data-lang=protobuf><span style=display:flex><span><span style=color:#66d9ef>message</span> <span style=color:#a6e22e>SingleNumber</span> {<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span>  <span style=color:#66d9ef>int32</span> Num <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span>}<span style=color:#960050;background-color:#1e0010>
</span></span></span></code></pre></div><pre tabindex=0><code>func main() {
    sn := SingleNumber {
        Num: 582963,
    }

    bytes, err := proto.Marshal(&amp;sn)
    if err != nil {
    panic(err)
    }

    fmt.Println(bytes)
}
</code></pre><p>The result obtained is the same as the steps mentioned above, where the first byte 8 is the key obtained by encoding the field:</p><pre tabindex=0><code>$ go run main.go msg.pb.go
[8 179 202 35]
</code></pre><p>Decoding process is also similar:</p><pre tabindex=0><code>func main() {
    b := []byte{8, 179, 202, 35}

    var sn SingleNumber
    err := proto.Unmarshal(b, &amp;sn)
    if err != nil {
        panic(err)
    }

    fmt.Println(sn.GetNum())
}
</code></pre><pre tabindex=0><code>$ go run main.go msg.pb.go
582963
</code></pre><h3 id=23-zigzag>2.3 ZigZag<a hidden class=anchor aria-hidden=true href=#23-zigzag>#</a></h3><p>The essence of Varint encoding is to remove leading zeros in the binary representation of a number in order to reduce the number of bytes used by the data. However, when it comes to negative numbers represented in <a href=https://www.ruanyifeng.com/blog/2009/08/twos_complement.html>two&rsquo;s complement</a>, using Varint for encoding would result in 5 bytes for a 32-bit number and 10 bytes for a 64-bit number, which is very inefficient. To optimize this, ProtoBuf uses ZigZag to map signed integers to unsigned integers. The encoding result of a positive number is equivalent to multiplying it by 2, while the encoding result of a negative number is equivalent to multiplying its absolute value by 2 and subtracting 1. The encoded value corresponds to the original data oscillating between positive and negative numbers, as shown in the table below:</p><table><thead><tr><th>Signed Integer</th><th>Unsigned Integer Encoding</th></tr></thead><tbody><tr><td>0</td><td>0</td></tr><tr><td>-1</td><td>1</td></tr><tr><td>1</td><td>2</td></tr><tr><td>-2</td><td>3</td></tr><tr><td>2147483647</td><td>4294967294</td></tr><tr><td>-2147483648</td><td>4294967295</td></tr></tbody></table><p>Its process is also very simple:</p><ol><li>Assume that the binary representation of the encoded number is num, and shift num left by 1 bit to get x.</li><li>Shift num right by 31 bits (the number of bits in num minus 1) to get y, that is, use the sign bit to cover each bit of num.</li><li>Perform XOR operation between x and y to get the result <code>z = x ^ y</code>.</li></ol><p>For example, for the positive number 5:</p><ol><li>x = 5 &#171; 1 = 00000000 00000000 00000000 00001010</li><li>y = 5 &#187; 31 = 00000000 00000000 00000000 00000000</li><li>z = x ^ y = 00000000 00000000 00000000 00001010, which is 10</li></ol><p>For the negative number -5:</p><ol><li>x = -5 &#171; 1 = 11111111 11111111 11111111 11110110</li><li>y = -5 &#187; 31 = 11111111 11111111 11111111 11111111</li><li>z = x ^ y = 00000000 00000000 00000000 00001001, which is 9</li></ol><p>In ProtoBuf, negative numbers are first encoded using ZigZag and then using Varint to achieve further data compression.</p><h3 id=24-other-encoding-processes>2.4 Other Encoding Processes<a hidden class=anchor aria-hidden=true href=#24-other-encoding-processes>#</a></h3><h3 id=variable-length-types>Variable-Length Types<a hidden class=anchor aria-hidden=true href=#variable-length-types>#</a></h3><p>For variable-length types (such as string, bytes, etc.) with <code>WireType == 2</code>, the serialized binary data stream is stored in the [Tag Length Value] format, where Length is the length of the variable-length part. For example:</p><pre tabindex=0><code>message SingleNumber {
  int32 Num = 1;
  string Str = 2;
}
</code></pre><pre tabindex=0><code>func main() {
    sn := SingleNumber {
        Num: 582963,
    Str: &#34;helloworld&#34;
    }

    bytes, err := proto.Marshal(&amp;sn)
    if err != nil {
    panic(err)
    }

    fmt.Println(bytes)
}
</code></pre><pre tabindex=0><code>$ go run main.go msg.pb.go
[8 179 202 35 18 10 104 101 108 108 111 119 111 114 108 100]
</code></pre><p>In the output, the fifth byte 18 is the Tag for <code>string Str = 2</code>, where <code>field_num = 2, wire_type = 2</code>; the sixth byte 10 represents the length of this variable-length type, which means that the value is stored from the seventh byte to the sixteenth byte, with each value being stored as an ASCII character.</p><h3 id=fixed-length-types>Fixed-length types<a hidden class=anchor aria-hidden=true href=#fixed-length-types>#</a></h3><p>For fixed-length types with <code>WireType == 1</code> or <code>WireType == 5</code> (such as fixed32, fixed64, etc.), the length of their serialized binary data is fixed at 4 or 8 bytes, respectively. For example:</p><pre tabindex=0><code>message SingleNumber {
  int32 Num = 1;
  string Str = 2;
  fixed32 A = 3;
  fixed64 B = 4;
  float C = 5;
}
</code></pre><pre tabindex=0><code>func main() {
  sn := SingleNumber {
        // Num: 582963,
        // Str: &#34;helloworld&#34;,
        A: 256,
        B: 257,
    }

    bytes, err := proto.Marshal(&amp;sn)
    if err != nil {
        fmt.Println(err)
        return
    }

    fmt.Println(bytes)
}
</code></pre><pre tabindex=0><code>$ go run main.go msg.pb.go
[29 0 1 0 0 33 1 1 0 0 0 0 0 0]
</code></pre><p>In the resulting bytes, the first byte represents the tag of <code>fixed32 A = 3</code>, where <code>field_num = 3, wire_type = 5</code>, and the following 4 bytes are directly stored according to byte order. The fifth byte represents the tag of <code>fixed64 B = 4</code>, where <code>field_num = 4, wire_type = 1</code>, and the following 8 bytes are similarly stored directly according to byte order.</p></div><footer class=post-footer><nav class=paginav><a class=next href=https://prov1dence.top/posts/data/redis-%E6%8C%81%E4%B9%85%E5%8C%96%E6%9C%BA%E5%88%B6-rdb-%E5%92%8C-aof-72a88c70207a4518824d1fe4be7ebb9e/><span class=title>Next Page »</span><br><span>Redis 持久化机制: RDB 和 AOF</span></a></nav></footer></article></main><footer class=footer><span>Zhengyu &copy; 2025</span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerText="copy";function s(){t.innerText="copied!",setTimeout(()=>{t.innerText="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>