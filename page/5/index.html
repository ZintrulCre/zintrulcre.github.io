<!doctype html><html lang=en dir=auto>
<head><meta charset=utf-8>
<meta http-equiv=x-ua-compatible content="IE=edge">
<meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no">
<meta name=robots content="index, follow">
<title>尾張</title>
<meta name=keywords content="Blog,Portfolio,PaperMod">
<meta name=description content="Providence's Blog">
<meta name=author content="Providence">
<link rel=canonical href=http://prov1dence.github.io/>
<meta name=google-site-verification content="XYZabc">
<meta name=yandex-verification content="XYZabc">
<meta name=msvalidate.01 content="XYZabc">
<link crossorigin=anonymous href=/assets/css/stylesheet.min.c88963fe2d79462000fd0fb1b3737783c32855d340583e4523343f8735c787f0.css integrity="sha256-yIlj/i15RiAA/Q+xs3N3g8MoVdNAWD5FIzQ/hzXHh/A=" rel="preload stylesheet" as=style>
<link rel=icon href=http://prov1dence.github.io/%3Clink%20/%20abs%20url%3E>
<link rel=icon type=image/png sizes=16x16 href=http://prov1dence.github.io/%3Clink%20/%20abs%20url%3E>
<link rel=icon type=image/png sizes=32x32 href=http://prov1dence.github.io/%3Clink%20/%20abs%20url%3E>
<link rel=apple-touch-icon href=http://prov1dence.github.io/%3Clink%20/%20abs%20url%3E>
<link rel=mask-icon href=http://prov1dence.github.io/%3Clink%20/%20abs%20url%3E>
<meta name=theme-color content="#2e2e33">
<meta name=msapplication-TileColor content="#2e2e33">
<meta name=generator content="Hugo 0.92.0">
<link rel=alternate type=application/rss+xml href=http://prov1dence.github.io/index.xml>
<link rel=alternate type=application/json href=http://prov1dence.github.io/index.json>
<noscript>
<style>#theme-toggle,.top-link{display:none}</style>
<style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style>
</noscript>
<script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(a,e,f,g,b,c,d){a.GoogleAnalyticsObject=b,a[b]=a[b]||function(){(a[b].q=a[b].q||[]).push(arguments)},a[b].l=1*new Date,c=e.createElement(f),d=e.getElementsByTagName(f)[0],c.async=1,c.src=g,d.parentNode.insertBefore(c,d)}(window,document,'script','https://www.google-analytics.com/analytics.js','ga'),ga('create','UA-132809676-1','auto'),ga('send','pageview'))</script><meta property="og:title" content="尾張">
<meta property="og:description" content="Providence's Blog">
<meta property="og:type" content="website">
<meta property="og:url" content="http://prov1dence.github.io/"><meta property="og:site_name" content="尾張">
<meta name=twitter:card content="summary">
<meta name=twitter:title content="尾張">
<meta name=twitter:description content="Providence's Blog">
<script type=application/ld+json>{"@context":"https://schema.org","@type":"Organization","name":"尾張","url":"http://prov1dence.github.io/","description":"Providence\u0026#39;s Blog","thumbnailUrl":"http://prov1dence.github.io/%3Clink%20/%20abs%20url%3E","sameAs":["https://github.com/ZintrulCre","https://www.linkedin.com/in/zintrulcre/","https://www.zhihu.com/people/zintrulcre"]}</script>
</head>
<body class=list id=top>
<script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add('dark'):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove('dark'):window.matchMedia('(prefers-color-scheme: dark)').matches&&document.body.classList.add('dark')</script>
<header class=header>
<nav class=nav>
<div class=logo>
<a href=http://prov1dence.github.io/ accesskey=h title="Home (Alt + H)">Home</a>
<span class=logo-switches>
<button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg>
</button>
</span>
</div>
<ul id=menu>
<li>
<a href=http://prov1dence.github.io/archives/ title=Archive>
<span>Archive</span>
</a>
</li>
<li>
<a href=http://prov1dence.github.io/about/ title=About>
<span>About</span>
</a>
</li>
</ul>
</nav>
</header>
<main class=main>
<article class=post-entry>
<header class=entry-header>
<h2>C++ 协程（1）：函数和协程
</h2>
</header>
<section class=entry-content>
<p>C++ 协程（1）：函数和协程 这篇文章的目的是探究 C++ 中协程的机制和用法，以及怎样利用协程的特性来构建上层的库和应用。
1. 栈帧和函数 栈帧是一个函数执行的环境，包括函数参数、函数返回地址、局部变量等信息。操作系统每次调用一个函数，都会为其分配一个新的栈帧，相关的概念有：
ESP：栈指针寄存器（Extended Stack Pointer），其内存中存放一个始终指向系统栈最顶部栈帧栈顶的指针 EBP：基址指针寄存器（Extended Base Pointer），其内存中存放一个始终指向系统最顶部栈帧栈底的指针 函数栈帧：ESP和EBP之间的内存空间为当前栈帧，EBP标识了当前栈帧的底部，ESP标识了当前栈帧的顶部 对于普通的函数来说，一般我们可以对其进行两种操作：call（调用）和 return（返回）。为了方便对比，此处不讨论 throw exception 的情况。在运行一个 C++ 程序时，编译器会先执行 C++ runtime，然后会调用 main 函数，再由 main 函数调用其他的函数。
call 操作一般包含以下几个步骤：
参数入栈：参数从右向左依次入栈 返回地址入栈：将当前代码区的下一条待执行的指令入栈，以便在函数 return 之后执行 代码区跳转：处理器跳转到被调函数的入口 栈帧调整，包括： 保存当前栈帧状态值，EBP 入栈 从当前栈帧切换到新的栈帧，更新 EBP，将 EBP 的值设置为 ESP 的值 给新的栈帧分配内存空间，更新 ESP，将 ESP 的值减去所需空间的大小 当一个函数通过 return 语句返回时，执行的步骤与调用时相反：
2. 协程 协程由程序所控制，即在用户态执行，而不是像线程一样由操作系统内核管理，使用协程时，不需要如线程一般频繁地进行上下文切换，性能能够得到很大的提升，因此协程的开销远远小于线程的开销。一般来说协程有三种特性：
suspend 悬停：暂停当前协程的执行，将执行权交还给调用者，但是保留当前栈帧。和函数的 return 类似，协程的 suspend 只能由协程自身发起 resume 恢复：继续执行已经 suspend 的协程，重新激活协程的栈帧 destroy 销毁：销毁协程的栈帧和其对应的内存 可以看到，协程可以在不清除栈帧的情况下被挂起而不被销毁，因此我们不能够使用调用栈这样的数据结构来严格保证活动栈帧的生命周期，我们可以把协程存储在堆中。我们可以把协程的栈帧分为两部分，一部分是执行栈帧，这部分仅在当前协程执行期间存在，在执行结束，即协程 suspend 的时候被释放；另一部分是数据栈帧，这部分即使在协程 suspend 的时候依然存在。...</p>
</section>
<footer class=entry-footer><span title="2020-01-20 20:15:05 +0800 CST">January 20, 2020</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;Providence</footer>
<a class=entry-link aria-label="post link to C++ 协程（1）：函数和协程" href=http://prov1dence.github.io/posts/c++/coroutine/c++-coroutine-function-and-coroutine/></a>
</article>
<article class=post-entry>
<header class=entry-header>
<h2>LeetCode 树（3）
</h2>
</header>
<section class=entry-content>
<p>LeetCode 树（3） 题目 4. 递归求解 617 合并二叉树 合并两个二叉树。
判断各个节点是否存在，全部合并到一棵树上即可。
class Solution { public: TreeNode *mergeTrees(TreeNode *t1, TreeNode *t2) { if (!t1 && !t2) return nullptr; else if (!t1) return t2; else if (!t2) return t1; t1->val += t2->val; t1->left = mergeTrees(t1->left, t2->left); t1->right = mergeTrees(t1->right, t2->right); return t1; } }; 226 翻转二叉树 翻转一个二叉树。
先将左右子树分别翻转，再交换两者的位置。
class Solution { public: TreeNode *invertTree(TreeNode *root) { if (!root) return nullptr; TreeNode *left = invertTree(root->left), *right = invertTree(root->right); root->right = left; root->left = right; return root; } }; 104 二叉树的最大深度 找出一个二叉树的最大深度。...</p>
</section>
<footer class=entry-footer><span title="2019-08-24 19:12:25 +1000 +1000">August 24, 2019</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Providence</footer>
<a class=entry-link aria-label="post link to LeetCode 树（3）" href=http://prov1dence.github.io/posts/leetcode/tree-3/></a>
</article>
<article class=post-entry>
<header class=entry-header>
<h2>LeetCode 排序
</h2>
</header>
<section class=entry-content>
<p>LeetCode 排序 题目 56 合并区间 按照间隔的起始进行排序，判断下一个间隔的起始是否大于前一个间隔的末尾，如果大于的话就把之前的间隔加入结果数组，否则继续扩展当前的间隔。
class Solution { public: vector&lt;vector&lt;int>> merge(vector&lt;vector&lt;int>> &intervals) { vector&lt;vector&lt;int>> res; int n = intervals.size(); if (n == 0) return res; sort(intervals.begin(), intervals.end(), [](vector&lt;int> const &v1, vector&lt;int> const &v2) { return v1[0] &lt; v2[0]; }); int start = intervals[0][0], end = intervals[0][1]; for (int i = 1; i &lt; n; ++i) { if (intervals[i][0] > end) { res.push_back(vector&lt;int>{start, end}); start = intervals[i][0]; } end = max(end, intervals[i][1]); } res....</p>
</section>
<footer class=entry-footer><span title="2019-08-17 19:12:25 +1000 +1000">August 17, 2019</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Providence</footer>
<a class=entry-link aria-label="post link to LeetCode 排序" href=http://prov1dence.github.io/posts/leetcode/sort/></a>
</article>
<article class=post-entry>
<header class=entry-header>
<h2>LeetCode 堆
</h2>
</header>
<section class=entry-content>
<p>LeetCode 堆 题目 215 数组中的第 K 个最大元素 最简单的堆的应用。
class Solution { public: int findKthLargest(vector&lt;int> &nums, int k) { priority_queue&lt;int, vector&lt;int>, greater&lt;>> heap; for (auto &m:nums) { if (heap.size() &lt; k || m > heap.top()) heap.push(m); if (heap.size() > k) heap.pop(); } return heap.top(); } }; 347 前 K 个高频元素 先遍历一次统计出数组中各个元素出现的次数，再用一个大根堆将前 k 个高频元素保存下来，最后再将这些元素依次 pop 出来存入结果数组。时间复杂度是 O(n)，空间复杂度是 O(n)。
class Solution { public: vector&lt;int> topKFrequent(vector&lt;int> &nums, int k) { priority_queue&lt;pair&lt;int, int>, vector&lt;pair&lt;int, int>>, greater&lt;>> freq; unordered_map&lt;int, int> count; vector&lt;int> res(k, 0); for (auto &m:nums) ++count[m]; for (auto &c:count) { freq....</p>
</section>
<footer class=entry-footer><span title="2019-08-05 19:12:25 +1000 +1000">August 5, 2019</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;Providence</footer>
<a class=entry-link aria-label="post link to LeetCode 堆" href=http://prov1dence.github.io/posts/leetcode/heap/></a>
</article>
<article class=post-entry>
<header class=entry-header>
<h2>LeetCode 双指针
</h2>
</header>
<section class=entry-content>
<p>LeetCode DFS 题目 26 删除排序数组中的重复项 用两个指针 len 和 i 分别表示没有重复的项的下标与遍历数组的下标，将没有重复的项拷贝到 nums[len] 下然后 ++len 即可。
class Solution { public: int removeDuplicates(vector&lt;int>& nums) { int count = 0, len = 1, n = nums.size(); if (n == 0) return 0; for (int i = 1; i &lt; n; ++i) { if (nums[i] == nums[i - 1]) continue; nums[len] = nums[i]; ++len; } return len; } }; 80 删除排序数组中的重复项 II 用两个指针 len 和 i 分别表示没有最多重复 2 次的项的下标与遍历数组的下标，将重复数小于等于 1 的项拷贝到 nums[len] 下然后 ++len 即可。...</p>
</section>
<footer class=entry-footer><span title="2019-07-31 19:12:25 +1000 +1000">July 31, 2019</span>&nbsp;·&nbsp;7 min&nbsp;·&nbsp;Providence</footer>
<a class=entry-link aria-label="post link to LeetCode 双指针" href=http://prov1dence.github.io/posts/leetcode/twopointers/></a>
</article>
<footer class=page-footer>
<nav class=pagination>
<a class=prev href=http://prov1dence.github.io/page/4/>« Prev Page</a>
<a class=next href=http://prov1dence.github.io/page/6/>Next Page »</a>
</nav>
</footer>
</main>
<footer class=footer>
<span>&copy; 2022 <a href=http://prov1dence.github.io/>尾張</a></span>
<span>
Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a>
</span>
</footer>
<a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a>
<script>let menu=document.getElementById('menu');menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(a=>{a.addEventListener("click",function(b){b.preventDefault();var a=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView({behavior:"smooth"}),a==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${a}`)})})</script>
<script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script>
<script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove('dark'),localStorage.setItem("pref-theme",'light')):(document.body.classList.add('dark'),localStorage.setItem("pref-theme",'dark'))})</script>
</body>
</html>